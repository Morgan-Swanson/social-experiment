name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET: social-experiment-terraform-state
  TF_LOCK_TABLE: social-experiment-terraform-locks

jobs:
  deploy:
    name: Deploy to AWS Production
    runs-on: ubuntu-latest
    
    env:
      TF_VAR_environment: cloud
      TF_VAR_project_name: social-experiment
      TF_VAR_aws_region: us-east-1
      TF_VAR_github_repo: Morgan-Swanson/social-experiment
      TF_VAR_github_branch: main
      TF_VAR_nextauth_secret: ${{ secrets.TF_VAR_nextauth_secret }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Create Terraform State Infrastructure
        run: |
          # Create S3 bucket for state if it doesn't exist
          if ! aws s3api head-bucket --bucket $TF_STATE_BUCKET 2>/dev/null; then
            echo "Creating S3 bucket for Terraform state..."
            aws s3api create-bucket --bucket $TF_STATE_BUCKET --region $AWS_REGION
            aws s3api put-bucket-versioning --bucket $TF_STATE_BUCKET --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket $TF_STATE_BUCKET --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket $TF_STATE_BUCKET --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
            echo "S3 bucket created successfully"
          else
            echo "S3 bucket already exists"
          fi
          
          # Create DynamoDB table for state locking if it doesn't exist
          if ! aws dynamodb describe-table --table-name $TF_LOCK_TABLE 2>/dev/null; then
            echo "Creating DynamoDB table for state locking..."
            aws dynamodb create-table \
              --table-name $TF_LOCK_TABLE \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region $AWS_REGION
            echo "Waiting for DynamoDB table to be active..."
            aws dynamodb wait table-exists --table-name $TF_LOCK_TABLE
            echo "DynamoDB table created successfully"
          else
            echo "DynamoDB table already exists"
          fi
          

      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Clear Stale Terraform Locks
        working-directory: ./terraform
        continue-on-error: true
        run: |
          # First try to init to get the lock info
          terraform init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=$AWS_REGION" \
            -backend-config="dynamodb_table=$TF_LOCK_TABLE" \
            -backend-config="encrypt=true" 2>&1 | tee init_output.txt || true
          
          # Extract lock ID if there's a lock error
          if grep -q "Error acquiring the state lock" init_output.txt; then
            LOCK_ID=$(grep "ID:" init_output.txt | awk '{print $2}')
            if [ -n "$LOCK_ID" ]; then
              echo "Found stale lock: $LOCK_ID"
              echo "Force unlocking..."
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          fi
          
          rm -f init_output.txt
      
      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init -reconfigure \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=$AWS_REGION" \
            -backend-config="dynamodb_table=$TF_LOCK_TABLE" \
            -backend-config="encrypt=true"
      
      - name: Import Existing Resources
        working-directory: ./terraform
        continue-on-error: true
        run: |
          # Import existing resources if they exist but aren't in state
          # These commands will fail gracefully if resources don't exist or are already imported
          
          echo "Checking for existing resources to import..."
          
          # Import VPC if exists
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=social-experiment-vpc" --query 'Vpcs[0].VpcId' --output text 2>/dev/null || echo "None")
          if [ "$VPC_ID" != "None" ] && [ "$VPC_ID" != "" ]; then
            echo "Found VPC: $VPC_ID"
            terraform import 'module.cloud[0].aws_vpc.main' "$VPC_ID" 2>/dev/null || echo "VPC already in state or import failed"
            
            # Import subnets
            for SUBNET_NAME in "public-a" "public-b" "private-a" "private-b"; do
              SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=social-experiment-${SUBNET_NAME}" --query 'Subnets[0].SubnetId' --output text 2>/dev/null || echo "None")
              if [ "$SUBNET_ID" != "None" ] && [ "$SUBNET_ID" != "" ]; then
                RESOURCE_NAME=$(echo $SUBNET_NAME | tr '-' '_')
                echo "Importing subnet $SUBNET_NAME: $SUBNET_ID"
                terraform import "module.cloud[0].aws_subnet.${RESOURCE_NAME}" "$SUBNET_ID" 2>/dev/null || echo "Subnet $SUBNET_NAME already in state"
              fi
            done
            
            # Import internet gateway
            IGW_ID=$(aws ec2 describe-internet-gateways --filters "Name=tag:Name,Values=social-experiment-igw" --query 'InternetGateways[0].InternetGatewayId' --output text 2>/dev/null || echo "None")
            if [ "$IGW_ID" != "None" ] && [ "$IGW_ID" != "" ]; then
              echo "Importing internet gateway: $IGW_ID"
              terraform import 'module.cloud[0].aws_internet_gateway.main' "$IGW_ID" 2>/dev/null || echo "IGW already in state"
            fi
            
            # Import route table
            RT_ID=$(aws ec2 describe-route-tables --filters "Name=tag:Name,Values=social-experiment-public-rt" --query 'RouteTables[0].RouteTableId' --output text 2>/dev/null || echo "None")
            if [ "$RT_ID" != "None" ] && [ "$RT_ID" != "" ]; then
              echo "Importing route table: $RT_ID"
              terraform import 'module.cloud[0].aws_route_table.public' "$RT_ID" 2>/dev/null || echo "Route table already in state"
              
              # Import route table associations
              PUBLIC_A_SUBNET=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=social-experiment-public-a" --query 'Subnets[0].SubnetId' --output text 2>/dev/null || echo "None")
              PUBLIC_B_SUBNET=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=social-experiment-public-b" --query 'Subnets[0].SubnetId' --output text 2>/dev/null || echo "None")
              
              if [ "$PUBLIC_A_SUBNET" != "None" ]; then
                ASSOC_A=$(aws ec2 describe-route-tables --route-table-ids "$RT_ID" --query "RouteTables[0].Associations[?SubnetId=='$PUBLIC_A_SUBNET'].RouteTableAssociationId" --output text 2>/dev/null || echo "None")
                if [ "$ASSOC_A" != "None" ] && [ "$ASSOC_A" != "" ]; then
                  echo "Importing route table association A: $ASSOC_A"
                  terraform import 'module.cloud[0].aws_route_table_association.public_a' "$ASSOC_A" 2>/dev/null || echo "Association A already in state"
                fi
              fi
              
              if [ "$PUBLIC_B_SUBNET" != "None" ]; then
                ASSOC_B=$(aws ec2 describe-route-tables --route-table-ids "$RT_ID" --query "RouteTables[0].Associations[?SubnetId=='$PUBLIC_B_SUBNET'].RouteTableAssociationId" --output text 2>/dev/null || echo "None")
                if [ "$ASSOC_B" != "None" ] && [ "$ASSOC_B" != "" ]; then
                  echo "Importing route table association B: $ASSOC_B"
                  terraform import 'module.cloud[0].aws_route_table_association.public_b' "$ASSOC_B" 2>/dev/null || echo "Association B already in state"
                fi
              fi
            fi
            
            # Import security group
            SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=social-experiment-db-sg" "Name=vpc-id,Values=$VPC_ID" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
            if [ "$SG_ID" != "None" ] && [ "$SG_ID" != "" ]; then
              echo "Importing security group: $SG_ID"
              terraform import 'module.cloud[0].aws_security_group.db' "$SG_ID" 2>/dev/null || echo "Security group already in state"
            fi
          fi
          
          # Import S3 bucket if exists
          if aws s3api head-bucket --bucket social-experiment-storage-423231905077 2>/dev/null; then
            echo "Importing S3 bucket"
            terraform import 'module.cloud[0].aws_s3_bucket.storage' "social-experiment-storage-423231905077" 2>/dev/null || echo "S3 bucket already in state"
          fi
          
          # Import IAM roles if exist
          if aws iam get-role --role-name social-experiment-app-role 2>/dev/null; then
            echo "Importing app IAM role"
            terraform import 'module.cloud[0].aws_iam_role.app' "social-experiment-app-role" 2>/dev/null || echo "App role already in state"
          fi
          
          if aws iam get-role --role-name social-experiment-amplify-role 2>/dev/null; then
            echo "Importing amplify IAM role"
            terraform import 'module.cloud[0].aws_iam_role.amplify' "social-experiment-amplify-role" 2>/dev/null || echo "Amplify role already in state"
          fi
          
          # Import Secrets Manager secrets if exist
          if aws secretsmanager describe-secret --secret-id "social-experiment/database-url" 2>/dev/null; then
            echo "Importing database URL secret"
            terraform import 'module.cloud[0].aws_secretsmanager_secret.database_url' "social-experiment/database-url" 2>/dev/null || echo "Database secret already in state"
          fi
          
          if aws secretsmanager describe-secret --secret-id "social-experiment/nextauth-secret" 2>/dev/null; then
            echo "Importing nextauth secret"
            terraform import 'module.cloud[0].aws_secretsmanager_secret.nextauth_secret' "social-experiment/nextauth-secret" 2>/dev/null || echo "NextAuth secret already in state"
          fi
          
          # Import CloudWatch log group if exists
          if aws logs describe-log-groups --log-group-name-prefix "/aws/amplify/social-experiment" --query 'logGroups[0].logGroupName' --output text 2>/dev/null | grep -q "social-experiment"; then
            echo "Importing CloudWatch log group"
            terraform import 'module.cloud[0].aws_cloudwatch_log_group.app' "/aws/amplify/social-experiment" 2>/dev/null || echo "Log group already in state"
          fi
          
          # Import DB subnet group if exists
          if aws rds describe-db-subnet-groups --db-subnet-group-name social-experiment-db-subnet 2>/dev/null; then
            echo "Importing DB subnet group"
            terraform import 'module.cloud[0].aws_db_subnet_group.main' "social-experiment-db-subnet" 2>/dev/null || echo "DB subnet group already in state"
          fi
          
          # Import RDS instance if exists
          if aws rds describe-db-instances --db-instance-identifier social-experiment-db 2>/dev/null; then
            echo "Importing RDS instance"
            terraform import 'module.cloud[0].aws_db_instance.postgres' "social-experiment-db" 2>/dev/null || echo "RDS instance already in state"
          fi
          
          # Import Amplify app if exists
          AMPLIFY_APP_ID=$(aws amplify list-apps --query "apps[?name=='social-experiment'].appId" --output text 2>/dev/null || echo "None")
          if [ "$AMPLIFY_APP_ID" != "None" ] && [ "$AMPLIFY_APP_ID" != "" ]; then
            echo "Importing Amplify app: $AMPLIFY_APP_ID"
            terraform import 'module.cloud[0].aws_amplify_app.main' "$AMPLIFY_APP_ID" 2>/dev/null || echo "Amplify app already in state"
          fi
          
          echo "Import check complete"
      
      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan
      
      - name: Output Deployment Info
        working-directory: ./terraform
        run: |
          echo "## Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Infrastructure Outputs:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Amplify URL:** \`$(terraform output -raw amplify_default_domain 2>/dev/null || echo 'pending')\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**S3 Bucket:** \`$(terraform output -raw storage_bucket 2>/dev/null || echo 'pending')\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Database Endpoint:** \`$(terraform output -raw db_instance_endpoint 2>/dev/null || echo 'pending')\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Connect GitHub to Amplify in AWS Console (first deployment only)" >> $GITHUB_STEP_SUMMARY
          echo "2. Add environment variables to Amplify (check Secrets Manager)" >> $GITHUB_STEP_SUMMARY
          echo "3. Trigger first Amplify deployment" >> $GITHUB_STEP_SUMMARY